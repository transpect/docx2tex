<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="http://transpect.io/xml2tex/schema/xml2tex.rng" type="application/xml" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-model href="http://transpect.io/xml2tex/schema/xml2tex.rng" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>
<set xmlns="http://transpect.io/xml2tex"  
     xmlns:tr="http://transpect.io"
     xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  
  <import href="conf.charmap.xml"/>

  <xsl:import href="http://transpect.io/mml2tex/xsl/mml2tex.xsl"/>
  <xsl:import href="http://transpect.io/xslt-util/colors/xsl/colors.xsl"/>
  <xsl:import href="http://transpect.io/xslt-util/paths/xsl/paths.xsl"/>
  <xsl:import href="http://transpect.io/xslt-util/roman-numerals/xsl/roman2int.xsl"/>
  
  <xsl:param name="table-model" as="xs:string"/>
  
  <xsl:variable name="xerif" as="xs:boolean" select="false()"/>
  <xsl:variable name="path"       as="xs:string"  select="tr:path(base-uri())" />
  <xsl:variable name="basename"   as="xs:string"  select="tr:basename(/dbk:hub/@xml:base)"/>
  <xsl:variable name="colors"     as="xs:string*"
                select="(
                         //@css:background-color,
                         //@css:color[not(every $i in  tr:hex-rgb-color-to-ints(.) satisfies $i &lt; 35  
                                          or parent::*[(@role, @name) = ('ZFinlineequation', 'ZFequation')]
                                          or ancestor::dbk:para/dbk:phrase[@role = ('ZFinlineequation', 'ZFequation', 'Hyperlink')]
                                          or ancestor-or-self::dbk:link
                                          or parent::*[@native-name eq 'Hyperlink'])],
                         for $mml2tex-color in (
                                        for $mml2tex-snippet in //processing-instruction('mml2tex')/tokenize(., '\\textcolor') 
                                        return replace($mml2tex-snippet, '\{([-a-z0-9]+?)\}.*$', '$1', 'i')
                                        )[not(position() eq 1)]
                         return if(starts-with($mml2tex-color, '#')) then $mml2tex-color else tr:color-keyword-to-hex-rgb($mml2tex-color)
                         )"/>
  <xsl:variable name="langs" select="distinct-values(//@xml:lang)" as="xs:string*"/>
  
  <xsl:variable name="footnotes" select="//dbk:footnote" as="element(dbk:footnote)*"/>
  
  <xsl:variable name="letter-spacing-def" select="'soul'" as="xs:string?">
    <!-- define which makro is used for letter spacing. allowed values: 
    - 'soul' creates \so and includes package soul 
    - 'microtype' creates \textls and includes package microtype 
    - '' creates \textls and includes no package (for overriding) -->
  </xsl:variable>

  <!-- elements where page breaks are ignored -->
  
  <xsl:variable name="elements-where-pagebreaks-are-ignored" as="xs:string+" 
                select="'part', 'chapter', 'section', 'index'"/>
  <xsl:variable name="titles-where-pagebreaks-are-ignored" as="xs:string+" 
                select="'part', 'chapter', 'section', 'index'"/>
  
  <xsl:key name="style" match="css:rule" use="@name"/>
  <xsl:key name="item-by-id" match="*[@xml:id]" use="@xml:id"/>
  
  <!-- tex document header, set declarations such as documentclass and usepackage -->
  <preamble>% docx2tex 1.9 --- ``How I learned to stop worrying and love DOCX''
    %
    % docx2tex is Open Source and 
    % you can download it on GitHub:
    % https://github.com/transpect/docx2tex
    % 
    \documentclass{scrbook}
    \usepackage[T1]{fontenc}
    \usepackage[utf8]{inputenc}
    <xsl:if test="//dbk:imagedata">
      <xsl:text>\usepackage{graphicx}&#xa;</xsl:text>
    </xsl:if>
    \usepackage{hyperref}
    \usepackage{multirow}
    \usepackage{tabularx}
    \usepackage{color}
    \usepackage{textcomp}
    <xsl:choose>
      <xsl:when test="//dbk:div[@role eq 'hub:index'][1]">
        <xsl:text>\usepackage[safe]{tipa}&#xa;</xsl:text>
      </xsl:when>
      <xsl:otherwise>
        <xsl:text>\usepackage{tipa}&#xa;</xsl:text>
      </xsl:otherwise>
    </xsl:choose>
    \usepackage{amsmath}
    \usepackage{amssymb}
    \usepackage{amsfonts}
    \usepackage{amsxtra}
    \usepackage{wasysym}
    \usepackage{isomath}
    \usepackage{mathtools}
    \usepackage{txfonts}
    \usepackage{upgreek}
    \usepackage{enumerate}
    \usepackage{tensor}
    \usepackage{pifont}
    \usepackage{ulem}
    \usepackage{xfrac}
    <xsl:if test="//*[@css:letter-spacing or exists(key('style', @role)/@css:letter-spacing)] and $letter-spacing-def[normalize-space()]">
      <xsl:value-of select="concat('\usepackage{', $letter-spacing-def,'}&#xa;')"/>
    </xsl:if>
    \usepackage{arydshln}
    <xsl:if test="//dbk:div[@role eq 'hub:index'][1]">
      <xsl:text>\usepackage{makeidx}&#xa;\makeindex&#xa;</xsl:text>
    </xsl:if>
    <xsl:sequence select="if(exists($langs)) 
                          then string-join(xml2tex:langs-to-latex-pkg( $langs ), '&#xa;') 
                          else string-join(xml2tex:langs-to-latex-pkg( 'en' ), '&#xa;')"/>
    <xsl:text>&#xa;</xsl:text>
    <xsl:for-each select="xml2tex:rgb-to-tex-color( $colors )">
      <xsl:value-of select="concat('\define', ., '&#xa;')"/>
    </xsl:for-each>
  </preamble>

  <!-- xml namespace declaration -->

  <ns prefix="dbk" uri="http://docbook.org/ns/docbook"/>
  <ns prefix="html" uri="http://www.w3.org/1999/xhtml"/>
  <ns prefix="css" uri="http://www.w3.org/1996/css"/>
  <ns prefix="svg" uri="http://www.w3.org/2000/svg"/>
  <ns prefix="docx2tex" uri="http://transpect.io/docx2tex"/>
  <ns prefix="mml2tex" uri="http://transpect.io/mml2tex"/>
  <ns prefix="tr" uri="http://transpect.io"/>

  <!-- drop metadata -->

  <template context="/dbk:hub/dbk:info"/>
  
  <!-- regular paras -->

  <template context="dbk:para[not(parent::*[local-name() = ('entry', 'th', 'td')])]
                             [following-sibling::*[1]]
                             [not(parent::dbk:listitem and not(following-sibling::*[1]))]
                             [not(following-sibling::*[1][self::dbk:orderedlist])]
                             [not(following-sibling::*[1][self::dbk:itemizedlist])]
                             [not(following-sibling::*[1][self::dbk:variablelist])]
                             [not(following-sibling::*[1][self::dbk:figure])]
                             [not(following-sibling::*[1][self::dbk:equation])]
                             [not(following-sibling::*[1][self::dbk:dialogue])]
                             [not(following-sibling::*[1][self::dbk:blockquote])]">
    <rule break-after="2">
      <text/>
    </rule>
  </template>
  
  <template context="*[not(local-name() = $elements-where-pagebreaks-are-ignored)]
                      [not(self::dbk:title and parent::dbk:info/parent::*/local-name() = $titles-where-pagebreaks-are-ignored)]
                      [@css:page-break-before eq 'always' or key('style', @role)/@css:page-break-before eq 'always']">
    <xsl:if test="$xerif"><xsl:text>\pagebreak&#xa;</xsl:text></xsl:if>
    <xsl:next-match/>
  </template>
  
  <!-- carriage returns -->
  
  <template context="dbk:phrase[@role eq 'cr']">
    <rule name="newline" type="cmd" break-after="1"/>
  </template>
  
  <!-- line breaks -->
  
  <template context="dbk:br">
    <rule name="newline" type="cmd" break-after="1"/>
  </template>
  
  <template context="dbk:br[following-sibling::node()[1][self::dbk:br]]">
    <rule name="newline" type="cmd"/>
  </template>

  <template context="dbk:title/dbk:br">
    <rule name="protect\newline" type="cmd" break-after="1"/>
  </template>
  
  <template context="dbk:entry//dbk:br[not($xerif)]">
    <rule>
      <text> \newline </text>
    </rule>
  </template>
  
  <template context="html:td//dbk:br[$table-model eq 'htmltabs']">
    <rule>
      <text> \htCellBreak </text>
    </rule>
  </template>
  
  <template context="dbk:entry[not(@*:morerows) or @*:morerows eq '0']/dbk:para[not(parent::dbk:footnote)]
                                                                               [following-sibling::dbk:para]//dbk:br[not($xerif)]">
    <rule>
      <text> \newline </text>
    </rule>
  </template>
  
  <template context="dbk:entry[not(@*:morerows) or @*:morerows eq '0']/dbk:para[not(parent::dbk:footnote)]
                                                                               [following-sibling::dbk:para][not($xerif)]">
    <rule>
      <xsl:next-match/>
      <text> \newline </text>
    </rule>
  </template>
  
  <template context="dbk:entry//dbk:br[every $precedent in ancestor::dbk:para[1]//node()[. &lt;&lt; current()] 
                                       satisfies (not(normalize-space($precedent)))]">
    <rule>
      <text>\leavevmode\newline
</text>  
    </rule>
  </template>

  <xsl:variable name="text-style-elements" select="'phrase', 'superscript', 'subscript'" as="xs:string+"/>

  <template context="*[local-name() = $text-style-elements]
                      [   (@css:letter-spacing and xs:double(replace(@css:letter-spacing, '[a-z]+$', '')) gt 0.5)
                       or exists(key('style', @role)[@css:letter-spacing[xs:double(replace(., '[a-z]+$', '')) gt 0.5]])]">
    <xsl:value-of select="if ($letter-spacing-def = 'soul') then '\so{' else '\textls{'"/>
    <xsl:next-match/>
    <xsl:text>}</xsl:text>
  </template>
  
  <template context="*[local-name() = $text-style-elements]
                      [@css:text-decoration-line ne 'none']
                      [   (@css:text-decoration-line[. eq 'underline'] 
                       or exists(key('style', @role)[@css:text-decoration-line eq 'underline']))]
		 [not(@role eq 'Hyperlink')] 
		 [not(parent::dbk:link) and exists(..)(:if no root exists:)]
		 [not(.//dbk:link)]">
    <xsl:value-of select="if (some $ a in (@css:text-decoration-style, 
                                           key('style', @role)/@css:text-decoration-style)
                              satisfies $a = 'double') 
                          then '\uuline{' 
                          else '\uline{'"/>
    <xsl:next-match/>
    <xsl:text>}</xsl:text>
  </template>
  
  <template context="*[local-name() = $text-style-elements]
                      [   @css:text-decoration-line eq 'line-through'
                       or exists(key('style', @role)[@css:text-decoration-line eq 'line-through'])]">
    <xsl:text>\sout{</xsl:text>
    <xsl:next-match/>
    <xsl:text>}</xsl:text>
  </template>
  
  <template context="dbk:para[not(@css:font-style eq 'normal')]
                             [@css:font-style eq 'italic'
                              or exists(key('style', @role)[@css:font-style eq 'italic'])]
                             [not(ancestor::dbk:info)]">
    <rule name="textit" type="cmd" break-after="2">
      <param/>
      <xsl:choose>
        <xsl:when test="parent::*[local-name() = ('entry', 'th', 'td')][not($xerif)]
                        and following-sibling::*[1]">
          <xsl:text>\newline&#xa;</xsl:text>
        </xsl:when>
        <xsl:when test="not(   parent::dbk:footnote
                            or (parent::dbk:listitem and not(following-sibling::*)))
                        and following-sibling::*[1]">
          <xsl:text>&#xa;&#xa;</xsl:text>
        </xsl:when>
      </xsl:choose>
    </rule>
  </template>
  
  <template context="dbk:para[not(@css:font-weight eq 'normal')]
                             [@css:font-weight eq 'bold'
                              or (    exists(key('style', @role)[@css:font-weight eq 'bold'])
                                  and not(@css:font-weight eq 'normal'))]">
    <rule name="textbf" type="cmd">
      <param/>
      <xsl:choose>
        <xsl:when test="parent::*[local-name() = ('entry', 'th', 'td')][not($xerif)]
                        and following-sibling::*[1]">
          <xsl:text>\newline&#xa;</xsl:text>
        </xsl:when>
        <xsl:when test="not(   parent::dbk:footnote
                            or (parent::dbk:listitem and not(following-sibling::*)))
                        and following-sibling::*[1]">
          <xsl:text>&#xa;&#xa;</xsl:text>
        </xsl:when>
      </xsl:choose>
    </rule>
  </template>

  <template context="dbk:*[@css:display eq 'none']">
    <rule>
      <text>&#xa;%</text>
      <text/>
      <text>&#xa;</text>
    </rule>
  </template>
  
  <template context="dbk:para[   @css:text-align='center'
                              or exists(key('style', @role)[@css:text-align eq 'center'])]
                             [not(parent::*/@css:text-align='center')]
                             [not(parent::dbk:entry or parent::*:th or parent::*:td)]">
    <xsl:text>{\centering </xsl:text>    
    <xsl:next-match/>
    <xsl:text>\par}</xsl:text>
  </template>
  
  <template context="dbk:para[   @css:text-align='right'
                              or exists(key('style', @role)[@css:text-align eq 'right'])]
                             [not(parent::*/@css:text-align='right')]
                             [not(parent::dbk:entry or parent::*:th or parent::*:td)]">
    <xsl:text>{\raggedleft </xsl:text>
    <xsl:next-match/>
    <xsl:text>\par}</xsl:text>
  </template>
  
  <template context="dbk:para[(    @css:text-align='left'
                               and key('style', @role)/@css:text-align = ('center', 'right'))
                              or (not(@css:text-align)
                                  and parent::*[local-name() = ('td', 'th', 'entry')]
                                  and following-sibling::*[1][@css:text-align[. ne 'left']])]
                             [not(parent::*/@css:text-align='left')]
                             [not(parent::dbk:entry or parent::*:th or parent::*:td)]">
    <xsl:text>{\raggedright </xsl:text>
    <xsl:next-match/>
    <xsl:text>\par}</xsl:text>
  </template>
  
  <!-- manually lowered or raised position -->
  
  <template context="dbk:phrase[(@css:top[. ne '0pt'], key('style', @role)/@css:top[. ne '0pt'])[1]]/text()">
    <rule>
      <text select="if(starts-with((parent::*/@css:top, key('style', parent::*/@role)/@css:top)[1], '-'))
                    then concat('\raisebox{', replace((parent::*/@css:top, key('style', parent::*/@role)/@css:top)[1], '^-', ''), '}')
                    else concat('\raisebox{-', (parent::*/@css:top, key('style', parent::*/@role)/@css:top)[1], '}')"/>
      <param/>
    </rule>
  </template>

  <!-- tables and figures -->

  <template context="dbk:table
                    |dbk:informaltable">
    <rule name="table" type="env">
      <text/>
    </rule>
  </template>

  <template context="dbk:figure/dbk:title|dbk:table/dbk:title">
    <rule break-before="1" name="caption" type="cmd">
      <param/>
    </rule>
  </template>

  <template context="dbk:figure">
    <rule name="figure" type="env">
      <text/>
      <text>&#xa;</text>
      <text select="concat('\label{fig:', index-of(for $i in //dbk:figure return generate-id($i), generate-id(.)), '}')"/>
    </rule>
  </template>
  
  <template context="dbk:alt"/>

  <template context="dbk:imagedata[@fileref]">
    <rule name="includegraphics" type="cmd">
      <option select="concat('width=', 
                             if(ancestor::dbk:figure)
                             then 1 div count(ancestor::dbk:figure[last()]//*[local-name() = ('mediaobject', 'inlinemediaobject')])
                             else 1,
                             '\textwidth')"/>
      <param select="replace(@fileref, '([%#])', '\\$1')"/>
    </rule>
  </template>
  
  <xsl:variable name="svg-images" as="element(svg:svg)*"
                select="//svg:svg"/>
  
  <template context="svg:svg">
    <xsl:variable name="svg-filename" select="concat($basename, '-svg-', index-of($svg-images, .)[1], '.svg')" as="xs:string"/>
    <xsl:variable name="svg-path" select="concat($path, '/', $svg-filename)" as="xs:string"/>
    <rule name="includegraphics" type="cmd">
      <param select="$svg-filename"/>
    </rule>
    <file href="{$svg-path}" encoding="utf-8" method="xml"/>
  </template>
  
  <!-- links -->
  
  <template context="dbk:link[@xlink:href][matches(@xlink:href, '^(https?|ftp):')]">
    <rule name="href" type="cmd">
      <param select="replace((@xlink:href, @url)[1], '([%#_\\])', '\\$1')"/>
      <param/>
    </rule>
  </template>

  <template context="dbk:link[@xlink:href][matches(@xlink:href, '^(https?|ftp):')]
                             [@xlink:href = replace(., '\\', '')]
                    |dbk:ulink">
    <rule name="url" type="cmd">
      <param select="replace((@xlink:href, @url)[1], '([%#])', '\\$1')"/>
    </rule>
  </template>
  
  <template context="dbk:link[@xlink:href][matches(@xlink:href, '^mailto:')]">
    <rule>
      <text/>
    </rule>
  </template>

  <!-- quotes -->

  <template context="dbk:blockquote">
    <rule name="quote" type="env" break-before="1">
      <text/>
    </rule>
  </template>
  
  <template context="dbk:para[not(parent::dbk:blockquote)][@role = ('Zitat', 'Quote')]">
    <rule name="quote" type="env" break-before="1">
      <text/>
    </rule>
  </template>

  <template context="dbk:blockquote[count(dbk:para) gt 1]">
    <rule name="quotation" type="env" break-before="1">
      <text/>
    </rule>
  </template>
  
  <!-- itemized lists -->

  <template context="dbk:itemizedlist">
    <rule name="itemize" type="env" break-before="1">
      <text/>
    </rule>
  </template>
  
  <template context="dbk:listitem[not(parent::dbk:varlistentry)][empty(@override)]">
    <rule name="item" type="cmd" break-before="1">
      <text select="' '"/>
      <text/>
    </rule>
  </template>
  
  <template context="dbk:listitem[@override][not(parent::dbk:varlistentry)]">
    <rule name="item" type="cmd" break-before="1">
      <option select="@override "/>
      <text select="' '"/>
      <text/>
    </rule>
  </template>
  
  <template context="dbk:orderedlist/dbk:listitem">
    <xsl:variable name="level" select="count(ancestor::*:orderedlist|ancestor::*:itemizedlist)" as="xs:integer"/>
    <xsl:variable name="level-roman" as="xs:string">
      <xsl:number value="$level" format="i"/>
    </xsl:variable>
    <xsl:variable name="pos" select="count(preceding-sibling::*) + 1" as="xs:integer"/>
    <xsl:variable name="override" select="@override" as="attribute(override)?"/>
    <xsl:variable name="numeration" select="parent::*/@numeration" as="attribute(numeration)?"/>
    <xsl:if test="    $override
                  and $numeration
                  and not(  tr:list-number-to-integer($override, $numeration) 
                          - preceding-sibling::*[1]/tr:list-number-to-integer(@override, parent::*/@numeration)
                          = 1 )
                  and $pos ne 1">
      <xsl:value-of select="concat('&#xa;\setcounter{enum', $level-roman, '}{', 
                                   xs:string(
                                               preceding-sibling::*[1]/tr:list-number-to-integer(@override, parent::*/@numeration)
                                             + tr:list-number-to-integer($override, $numeration)
                                             - preceding-sibling::*[1]/tr:list-number-to-integer(@override, parent::*/@numeration)
                                             - 1), 
                                   '}&#xa;')"/>
    </xsl:if>
    <rule name="item" type="cmd" break-before="1">
      <xsl:if test="matches(@override, '[a-z0-9]\.([a-z0-9])+')">
        <option select="@override"/>
      </xsl:if>
      <text select="' '"/>
      <text/>
    </rule>
  </template>
  
  <!-- orderedlists are handled in enum.xsl -->
  
  <!-- variable list -->
  
  <template context="dbk:variablelist">
    <xsl:variable name="max-length" as="xs:integer"
                  select="max(dbk:varlistentry/dbk:term/string-length(replace(., '\{\\slash\}', '/')))"/>
    <xsl:variable name="longest-word" as="xs:string" 
                  select="dbk:varlistentry[dbk:term[string-length(replace(., '\{\\slash\}', '/')) eq $max-length]][1]/dbk:term"/>
    <rule name="description" type="env" break-before="1">
      <option select="$longest-word"/>
      <text/>
    </rule>
  </template>
  
  <template context="dbk:term[parent::dbk:varlistentry]">
    <rule name="item" type="cmd" break-before="1">
      <option/>
    </rule>
  </template>  

  <!-- text styles -->
  
  <template context="*[local-name() = $text-style-elements]
                      [@css:color or key('style', @role)/@css:color]
                      [not(every $i in  tr:hex-rgb-color-to-ints((@css:color, key('style', @role)/@css:color)[1]) 
                           satisfies $i &lt; 35)]
                      [not(@role = ('ZFinlineequation', 'ZFequation', 'ZFVerweis', 'ZFCaption', 'NOTE-CE', 'NOTE-TS', 'Hyperlink'))]
                      [not(preceding-sibling::*[@role = ('ZFinlineequation', 'ZFequation')])]
                      [not(following-sibling::*[@role = ('ZFinlineequation', 'ZFequation')])]
                      [not(ancestor-or-self::dbk:link)]/text()">
    <xsl:text>\textcolor{</xsl:text>
    <xsl:value-of select="for $color-code in (parent::*/@css:color, key('style', parent::*/@role)/@css:color)[1] 
                          return if(exists(tr:color-hex-rgb-to-keyword($color-code)))
                                 then tr:color-hex-rgb-to-keyword($color-code)[1]
                                 else concat('color-', upper-case(substring-after($color-code, '#')))"/>
    <xsl:text>}{</xsl:text>
    <xsl:next-match/>
    <xsl:text>}</xsl:text>
  </template>

  <template context="*[local-name() = $text-style-elements]
                      [@css:font-style eq 'normal']
                      [   ancestor-or-self::*[local-name() = $text-style-elements]/@css:font-style = 'italic'
                       or (some $role in ancestor-or-self::*[@role]/@role
                           satisfies exists(key('style', @role)[@css:font-style eq 'italic']))]">
    <xsl:text>\textup{</xsl:text>
    <xsl:next-match/>
    <xsl:text>}</xsl:text>
  </template>
  
  <template context="*[local-name() = $text-style-elements]
                      [    @css:font-weight eq 'normal' or @css:font-style eq 'normal']
                      [not(@css:font-weight eq 'bold'   or @css:font-style eq 'italic')]
                      [(ancestor::*[local-name() = $text-style-elements]/((@css:font-style, 
                                                                           @css:font-weight, 
                                                                           @css:font-variant) != 'normal')
                        or empty(ancestor::*[local-name() = $text-style-elements]
                                           [@css:font-style|@css:font-weight]))
                       or (some $role in ancestor::*[@role]/@role
                           satisfies exists(key('style', @role)[(@css:font-style, 
                                                                 @css:font-weight, 
                                                                 @css:font-variant) != 'normal']))]    ">
    <xsl:text>\textnormal{</xsl:text>
    <xsl:next-match/>
    <xsl:text>}</xsl:text>
  </template>
  
  <template context="*[local-name() = $text-style-elements]
                      [   @css:font-style eq 'italic' 
                       or (    exists(key('style', @role)[@css:font-style eq 'italic'])
                           and not(@css:font-style eq 'normal'))]">
    <xsl:text>\textit{</xsl:text>
    <xsl:next-match/>
    <xsl:text>}</xsl:text>
  </template>
  
  <template context="*[local-name() = $text-style-elements]
                      [   @css:font-weight eq 'bold'
                       or (    exists(key('style', @role)[@css:font-weight eq 'bold'])
                           and not(@css:font-weight eq 'normal'))]">
    <xsl:text>\textbf{</xsl:text>
    <xsl:next-match/>
    <xsl:text>}</xsl:text>
  </template>
  
  <template context="*[local-name() = $text-style-elements]
                      [@css:font-style eq 'italic' or @css:font-weight eq 'bold']
                      [matches(., '^[&#x393;&#x394;&#x398;&#x39b;&#x39e;&#x3a0;&#x3a3;&#x3a5;&#x3a6;&#x3a8;-&#x3be;&#x3c0;-&#x3f6;]$')]">
    <rule>
      <text/>
    </rule>
  </template>
  
  <template context="*[local-name() = $text-style-elements]
                      [   @css:font-family = ('Consolas', 'Courier New', 'Courier')
                       or exists(key('style', @role)[@css:font-family = ('Consolas', 'Courier New', 'Courier')])]">
    <xsl:text>\texttt{</xsl:text>
    <xsl:next-match/>
    <xsl:text>}</xsl:text>
  </template>

  <template context="*[local-name() = $text-style-elements]
                      [    (@css:font-variant eq 'small-caps'
                            or exists(key('style', @role)[@css:font-variant eq 'small-caps']))
                       and not(@css:text-transform eq 'uppercase'
                               or exists(key('style', @role)[@css:text-transform eq 'uppercase']))]">
    <xsl:text>\textsc{</xsl:text>
    <xsl:next-match/>
    <xsl:text>}</xsl:text>
  </template>

  <template context="*[local-name() = $text-style-elements]
                      [not(@css:background-color eq '#FFFFFF')
                                and (@css:background-color 
                                or exists(key('style', @role)[@css:background-color and not(@css:background-color eq '#FFFFFF') ]))]
                               [not(.//dbk:footnote)]">
    <rule name="colorbox" type="cmd">
      <param select="for $color-code in (@css:background-color, key('style', @role)/@css:background-color)[1] 
                     return if(exists(tr:color-hex-rgb-to-keyword($color-code)))
                            then tr:color-hex-rgb-to-keyword($color-code)[1]
                            else concat('color-', upper-case(substring-after($color-code, '#')))"/>
      <xsl:text>{</xsl:text>
      <xsl:next-match/>
      <xsl:text>}</xsl:text>
    </rule>
  </template>

  <!-- regular superscript and subscripts -->
  
  <template context="dbk:subscript
                    |dbk:phrase[not(dbk:footnote)]
                               [key('style', @role)[@remap eq 'subscript']]">
    <xsl:text>\textsubscript{</xsl:text>
    <xsl:next-match/>
    <xsl:text>}</xsl:text>
  </template>
  
  <template context="dbk:superscript[not(dbk:footnote)]
                    |dbk:phrase[not(dbk:footnote)]
                               [key('style', @role)[@remap eq 'superscript']]">
    <xsl:text>\textsuperscript{</xsl:text>
    <xsl:next-match/>
    <xsl:text>}</xsl:text>
  </template>

  <!-- headlines -->
  
  <template context="dbk:para[@docx2tex:config eq 'headline']/dbk:phrase[@role eq 'docx2tex:identifier']">
    <rule>
      <text/>
      <text select="' '"/>
    </rule>
  </template>

  <template context="dbk:para[@role = ('berschrift1', 'headline1', 'heading1', 'Heading1')]">
    <rule break-after="2" name="chapter" type="cmd">
      <param/>
    </rule>
  </template>

  <template context="dbk:para[@role = ('berschrift2', 'headline2', 'heading2', 'Heading2')]">
    <rule break-after="2" name="section" type="cmd">
      <param/>
    </rule>
  </template>

  <template context="dbk:para[@role = ('berschrift3', 'headline3', 'heading3', 'Heading3')]">
    <rule break-after="2" name="subsection" type="cmd">
      <param/>
    </rule>
  </template>

  <template context="dbk:para[@role = ('berschrift4', 'headline4', 'heading4', 'Heading4')]">
    <rule break-after="2" name="subsubsection" type="cmd">
      <param/>
    </rule>
  </template>

  <template context="dbk:para[@role = ('berschrift5', 'headline5', 'heading5', 'Heading5')]">
    <rule break-after="2" name="paragraph" type="cmd">
      <param/>
    </rule>
  </template>

  <template context="dbk:para[matches(@role, '(berschrift|headline|heading)[6-9]', 'i')]">
    <rule break-after="2" name="subparagraph" type="cmd">
      <param/>
    </rule>
  </template>

  <xsl:variable name="footnote-ids" as="xs:string*" 
                select="for $i in $footnotes return generate-id($i)"/>

  <template context="dbk:footnote">
    <xsl:variable name="pos" as="xs:integer" 
                  select="index-of($footnote-ids, generate-id())"/>
    <xsl:variable name="preceding-regular-fn-count" as="xs:integer" 
                  select="count(
                                for $i in (1 to $pos) 
                                return $footnotes[$i][not(.//dbk:phrase[@role eq 'hub:identifier'][1][@xreflabel])]
                                )"/>
    <xsl:value-of select=".//dbk:phrase[@role eq 'hub:identifier'][1]
                            /@xreflabel/concat('\renewcommand*{\thefootnote}{',
                                                    if(matches(., '\*'))      then '\fnsymbol'
                                               else if(matches(., 'ivxlcdm')) then '\roman'
                                               else if(matches(., 'IVXLCDM')) then '\Roman'
                                               else if(matches(., '[a-z]'))   then '\alph'
                                               else if(matches(., '[A-Z]'))   then '\Alph'
                                               else if(matches(., '[\*†‡§]')) then '\fnsymbol'
                                               else                                '\arabic',
                                               '{footnote}}')"/>
    <rule name="footnote" type="cmd">
      <param/>
    </rule>
    <xsl:value-of select=".//dbk:phrase[@role eq 'hub:identifier'][1]/@xreflabel/concat(
                                                                                        '\renewcommand*{\thefootnote}{\arabic{footnote}}',
                                                                                        '\setcounter{footnote}{',
                                                                                        xs:string($preceding-regular-fn-count),
                                                                                        '}'
                                                                                        )"/>
  </template>
  
  <template context="dbk:informaltable//dbk:footnote
                    |dbk:table//dbk:footnote">
    <rule name="footnotemark" type="cmd">
      <param select="()"/>
    </rule>
  </template>
  
  <template context="dbk:informaltable[.//dbk:footnote]
                    |dbk:table[.//dbk:footnote]">
    <xsl:next-match/>
    <xsl:for-each select=".//dbk:footnote">
      <xsl:value-of select="concat('\footnotetext[', index-of($footnotes, .), ']{')"/>
      <xsl:apply-templates mode="#current"/>
      <xsl:text>}&#xa;</xsl:text>
    </xsl:for-each>
  </template>

  <template context="dbk:footnote/dbk:para[following-sibling::dbk:para]">
    <rule break-after="1">
      <text/>
    </rule>
  </template>
  
  <template context="dbk:footnote[count(*) eq 1]/dbk:para">
    <rule>
      <text/>
    </rule>
  </template>
  
  <!-- remove leading whitespace in footnotes -->
    
  <template context="dbk:footnote/dbk:para[1]//text()[preceding-sibling::node()[1][@role eq 'hub:identifier']][starts-with(., ' ')]
                    |dbk:footnote/dbk:para[1]//dbk:phrase[preceding-sibling::node()[1][@role eq 'hub:identifier']][starts-with(., ' ')]
                    |dbk:footnote/dbk:para[1]/dbk:phrase[preceding-sibling::*[1][@role eq 'hub:identifier']]
                                                        [preceding-sibling::node()[1][not(normalize-space())]]
                                                        [starts-with(., ' ')]">
    <rule>
      <text select="replace(string-join(xml2tex:utf2tex(.., ., $charmap, (), $texregex), ''), '^\s', '')"/> 
    </rule>
  </template>
    
  <template context="dbk:footnote/dbk:para[1]//text()[preceding-sibling::node()[1][@role eq 'hub:identifier']]
                                                     [not(normalize-space())]"/>  
  
  <!-- remove footnote numbers and whitespace -->
  
  <template context="dbk:footnote//dbk:phrase[@role eq 'hub:separator']"/>

  <template context="dbk:footnote/dbk:para[1]/dbk:phrase[@role eq 'hub:identifier'][1]
                                                        [not(descendant-or-self::dbk:anchor 
                                                             or descendant-or-self::processing-instruction())]
                                                         //text()[1]">
    <xsl:value-of select="replace(., '^[\d*†‡§i\s]+\.?\s*', '', 'i')"/>
  </template>
  
  <template context="dbk:footnote/dbk:para/*[1][local-name() eq 'superscript'][matches(., '\d+')]"/>

  <!-- equations -->

  <template context="dbk:inlineequation[not(ancestor::dbk:superscript or ancestor::dbk:subscript )]
                    |dbk:equation[ancestor::dbk:table or ancestor::dbk:informaltable]">
    <rule>
      <text select="'$'"/>
      <text/>
      <text select="'$'"/>
    </rule>
  </template>

  <template context="dbk:equation[@condition eq 'numbered']
                                 [not(ancestor::dbk:table or ancestor::dbk:informaltable)]">
    <rule name="equation" type="env" break-before="1">
      <text>&#xa;</text>
      <text/>
    </rule>
  </template>
  
  <template context="dbk:equation[not(@condition eq 'numbered')]
                                 [not(ancestor::dbk:table or ancestor::dbk:informaltable)]">
    <rule name="equation*" type="env" break-before="1">
      <text>&#xa;</text>
      <text/>
    </rule>
  </template>
  
  <template context="dbk:equation[@condition eq 'numbered'][not(ancestor::dbk:table or ancestor::dbk:informaltable)]
                                 [not(some $i in processing-instruction() satisfies contains($i, '\begin{array}'))]
                                 [some $i in processing-instruction() satisfies contains($i, '\\')]">
    <rule name="align" type="env" break-before="1">
      <text>&#xa;</text>
      <text/>
    </rule>
  </template>
  
  <template context="dbk:equation[not(@condition eq 'numbered')]
                                 [not(ancestor::dbk:table or ancestor::dbk:informaltable)]
                                 [not(some $i in processing-instruction() satisfies contains($i, '\begin{array}'))]
                                 [some $i in processing-instruction() satisfies contains($i, '\\')]">
    <rule name="align*" type="env" break-before="1">
      <text>&#xa;</text>
      <text/>
    </rule>
  </template>
  
  <template context="processing-instruction('tr')[starts-with(., 'M2M_212')]">
    <rule>
      <text>% D2T: Equation not converted. See log for details!&#xa;</text>
    </rule>
  </template>
  
  <template context="processing-instruction('d2t')[starts-with(., 'D2T 001')]">
    <rule>
      <text>% D2T: Empty equation removed!&#xa;</text>
    </rule>
  </template>
  
  <!-- replace tabs -->
  
  <!-- resolve tab when it's the begin of a term or a tab definition -->
  
  <template context="dbk:term/node()[1][self::dbk:tab]
                    |dbk:tabs"/>
  
  
  <template context="dbk:tab
                    |dbk:phrase[@role eq 'tab']">
    <rule>
      <text>&#x9;</text>
    </rule>
  </template>
  
  <template context="dbk:tab[@xml:space eq 'preserve']
                            [preceding-sibling::dbk:inlineequation and following-sibling::dbk:inlineequation]">
    <rule>
      <text>{\quad}</text>
    </rule>
  </template>
  
  <template context="dbk:footnote//dbk:tab[@role eq 'hub:separator']"/>
  
  <!-- tagged private use area -->
  <template context="dbk:phrase[@role eq 'unicode-private-use']">
    <rule name="privateuse" type="cmd">
      <param/>
    </rule>
  </template>

  <!-- comments -->

  <template context="dbk:annotation">
    <rule break-after="1">
      <text select="concat(if(parent::*/following-sibling::node()[1][self::text()][matches(., '^\s')])
                           then ' '
                           else '',
                           '%', string-join(.//node(), 
                           ' '))"/>
    </rule>
  </template>

  <!-- toc -->
  
  <template context="dbk:para[@role = ('Inhaltsverzeichnisberschrift', 'TOC Heading')]">
    <rule break-after="2">
      <text select="concat('\renewcommand{\contentsname}{', ., '}')"/>
    </rule>
  </template>
  
  <template context="dbk:div[@role eq 'hub:toc']">
    <rule break-after="2">
      <text>\tableofcontents</text>
    </rule>
  </template>

  <!-- indexterms -->

  <template context="dbk:indexterm[not(@type)]">
    <rule name="index" type="cmd">
      <xsl:call-template name="index-content"/>
    </rule>
  </template>

  <template context="dbk:indexterm[@type]">
    <xsl:param name="as-option" as="xs:boolean?" tunnel="yes"/>
    <!-- param as option is automatically set in xml2tey if an option was triggered -->
    <xsl:if test="$as-option"><xsl:text>{</xsl:text></xsl:if>
    <rule name="index" type="cmd">
      <option select="@type"/>
      <xsl:call-template name="index-content"/>
    </rule>
    <xsl:if test="$as-option"><xsl:text>}</xsl:text></xsl:if>
  </template>
  
  <xsl:template name="index-content">
    <xsl:choose>
      <xsl:when test="@class eq 'startofrange'">
        <text>{</text>
        <text/>
        <text>|(}</text>
      </xsl:when>
      <xsl:when test="@class eq 'endofrange'">
        <text>{</text>
        <text select="key('item-by-id', @startref)/node()"/>
        <text>|)}</text>
      </xsl:when>
      <xsl:otherwise>
        <param/>    
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
    
  <template context="dbk:indexterm[not(normalize-space())][not(@class)]"/>
  
  <template context="dbk:primary">
    <rule>
      <xsl:if test="@sortas[normalize-space()]">
        <text select="concat(@sortas, '@')"/>
      </xsl:if>
      <text/>
    </rule>
  </template>
  
  <template context="*[local-name() = ('primary', 
                                       'secondary', 
                                       'tertiary', 
                                       'quaternary', 
                                       'quinary', 
                                       'senary', 
                                       'septenary', 
                                       'octonary', 
                                       'nonary', 
                                       'denary')]
                      [@css:font-weight eq 'bold'
                       or (    exists(key('style', @role)[@css:font-weight eq 'bold'])
                           and not(@css:font-weight eq 'normal'))]">
    <xsl:text>\textbf{</xsl:text>
    <xsl:next-match/>
    <xsl:text>}</xsl:text>
  </template>
  
  <template context="*[local-name() = ('primary', 
                                       'secondary', 
                                       'tertiary', 
                                       'quaternary', 
                                       'quinary', 
                                       'senary', 
                                       'septenary', 
                                       'octonary', 
                                       'nonary', 
                                       'denary')]
                      [@css:font-style eq 'italic'
                       or exists(key('style', @role)[@css:font-style eq 'italic'])]">
    <xsl:text>\textit{</xsl:text>
    <xsl:next-match/>
    <xsl:text>}</xsl:text>
  </template>
  
  <template context="dbk:secondary
                    |dbk:tertiary
                    |dbk:quaternary
                    |dbk:quinary
                    |dbk:senary
                    |dbk:septenary
                    |dbk:octonary
                    |dbk:nonary
                    |dbk:denary">
    <rule>
      <text>!</text>
      <xsl:if test="@sortas[normalize-space()]">
        <text select="concat(@sortas, '@')"/>
      </xsl:if>
      <text/>
    </rule>
  </template>
  
  <xsl:variable name="see-regex" as="xs:string" 
                select="'^(see\salso|see|voir|véase|vedi|ver|siehe\sauch|siehe|请参阅|ראה|انظر|참조)\p{Zs}*(.*?)$'"/>
  
  <xsl:variable name="see-also-regex" as="xs:string" 
                select="'^(((see\s)?also)|((siehe\s)?auch))$'"/>
  
  <template context="dbk:see|dbk:seealso">
    <rule>
      <text select="if(   matches(string-join(dbk:phrase[@css:font-style eq 'italic'], ' '), $see-also-regex)
                       or self::dbk:seealso)
                     then '|seealso{' 
                     else '|see{'"/>
      <text select="node() except node()[matches(., $see-also-regex)]"/>
      <text>}</text>
    </rule>
  </template>

  <template context="*[local-name() = ('see', 'seealso')]/dbk:phrase[@css:font-style eq 'italic']
                                                                    [matches(., $see-regex) or matches(., $see-also-regex)]
                    |*[local-name() = ('see', 'seealso')]/text()[matches(., $see-regex) or matches(., $see-also-regex)]">
    <xsl:value-of select="replace(replace(., '!', '&quot;!'), 
                                  $see-regex, 
                                  '$2', 
                                  'i')"/>
    
  </template>

  <template context="*[local-name() = ('see', 'seealso')]/text()[preceding-sibling::node()[1][self::dbk:phrase[@css:font-style eq 'italic']]
                                                                                             [matches(., $see-regex) or matches(., $see-also-regex)]]">
    <xsl:value-of select="replace(., '^\s+', '')"/>
  </template>

    
  
  <template context="*[local-name() = ('see', 'seealso')]/text()[preceding-sibling::*[1][self::dbk:phrase[@css:font-style eq 'italic'][matches(., $see-regex)]]]">
    <xsl:value-of select="replace(replace(., '!', '&quot;!'), '^\p{Zs}+', '')"/>
  </template>
  
  <template context="*[local-name() = ('primary', 
                                       'secondary', 
                                       'tertiary', 
                                       'quaternary', 
                                       'quinary', 
                                       'senary', 
                                       'septenary', 
                                       'octonary', 
                                       'nonary', 
                                       'denary')]//text()[matches(., '[|!@&quot;]')]">
    <rule>
      <text select="replace(replace(., '([!@&quot;])', '&quot;$1'),
                            '\|',
                            '\\textbar{}')"/>
    </rule>
  </template>
  
  <template context="dbk:index[not(.//dbk:indexentry)]">
    <rule name="printindex" type="cmd" break-after="1">
      <option select="@remap"/>
      <text select="concat('%%%', @remap)"/>
    </rule>
  </template>
  
  <!-- static index -->
  
  <template context="dbk:index[.//dbk:indexentry]">
    <xsl:variable name="index-path" as="xs:string"
                  select="concat($path, '/', $basename, '.', @remap/concat(., '_'), 'ind')"/>
    <xsl:if test="dbk:title and not(@remap)">
      <xsl:value-of select="concat('\renewcommand{\indexname}{', dbk:title, '}&#xa;')"/>
    </xsl:if>
    <rule name="printindex" type="cmd" break-after="1">
      <option select="@remap"/>
    </rule>
    <file href="{$index-path}" encoding="utf-8"/>
  </template>
  
  <template context="dbk:index[.//dbk:indexentry]/node()">
    <xsl:apply-templates mode="#current"/>
  </template>
  
  <template context="dbk:index[.//dbk:indexentry]/dbk:title | dbk:index/dbk:info"/>

  <template context="dbk:index[.//dbk:indexentry]//dbk:indexdiv">
    <xsl:if test="not(preceding-sibling::dbk:indexdiv)">
      <xsl:value-of select="string-join(('\begin{theindex}',
                                         '  \providecommand*\lettergroupDefault[1]{}',
                                         '  \providecommand*\lettergroup[1]{%',
                                         '    \par\textbf{#1}\par',
                                         '    \nopagebreak',
                                         '  }'), 
                                        '&#xa;')"/>
    </xsl:if>
    <xsl:value-of select="concat('&#xa;&#x20;&#x20;\indexspace&#xa;&#xa;&#x20;&#x20;\lettergroup{', dbk:title, '}\nopagebreak&#xa;&#xa;')"/>
    <xsl:apply-templates select="dbk:indexentry" mode="#current"/>
    <xsl:if test="not(following-sibling::dbk:indexdiv)">
      <xsl:text>\end{theindex}</xsl:text>
    </xsl:if>
  </template>
  
  <template context="dbk:indexentry">
    <xsl:text>&#x20;&#x20;</xsl:text>
    <rule name="item" type="cmd" break-after="1">
      <text>&#x20;</text>
      <text/>
    </rule>
  </template>
  
  <template context="dbk:seeie">
    <rule name="see" type="cmd" break-after="1">
      <param/>
      <param select="()"/>
    </rule>
  </template>
  
  <template context="dbk:primaryie//dbk:xref
                    |dbk:seeie//dbk:xref">
    <rule>
      <text select="replace(@xlink:href, '^page-', '')"/>
    </rule>
  </template>

  <!-- index listing -->
  
  <template context="dbk:para[@role = ('Index_Heading', 'Indexberschrift')]"/>
  
  <template context="dbk:div[@role eq 'hub:index']">
    <rule break-after="2">
      <text select="if(//dbk:para[@role = ('Index_Heading', 'Indexberschrift')][string-length() gt 0]) 
                    then concat('\renewcommand{\indexname}{', 
                                //dbk:para[@role = ('Index_Heading', 'Indexberschrift')][string-length() gt 0][1], 
                                '}&#xa;\printindex')
                    else '\printindex'"/>
    </rule>
  </template>
  
  <!-- textbox -->
  
  <template context="dbk:sidebar">
    <rule break-after="2" break-before="1">
      <text>\fbox{\begin{minipage}[t]{0.8\textwidth}</text>
      <text/>
      <text>\end{minipage}}</text>
    </rule>
  </template>
  
  <!-- babel support -->
  
  <template context="dbk:phrase[@xml:lang]
                               [normalize-space(.)]
                               [xml2tex:lang-to-babel-lang(@xml:lang)]
                               [not(parent::dbk:link)]
                               [every $lang in @xml:lang
                                satisfies not(ancestor::*[@xml:lang][1]/@xml:lang = $lang)]
                               [not(ancestor::dbk:entry or self::dbk:term or self::dbk:listitem)]
                               [not((*/local-name() = ('link', 'mediaobject', 'inlinemediaobject'))
                                    and 
                                    not(normalize-space(string-join(.//text()[not(ancestor::*/local-name() = ('link', 'mediaobject', 'inlinemediaobject'))], '')))
                                   )]
                               [not(matches(., '^[\p{P}\p{Z}\d&#x4e00;-&#x9fff;&#x530;-&#x58f;&#xfb13;-&#xfb17;]+$'))]">
    <xsl:param name="suppress-foreign-lang" as="xs:boolean?" tunnel="yes"/>
    <xsl:value-of select="if(    $suppress-foreign-lang 
                             and not(xml2tex:lang-to-babel-lang(@xml:lang) = ('greek', 
                                                                              'arabic', 
                                                                              'hebrew', 
                                                                              'japanese', 
                                                                              'chinese', 
                                                                              'syriac', 
                                                                              'armenian'))) 
                          then () 
                          else concat('\foreignlanguage{', xml2tex:lang-to-babel-lang(@xml:lang), '}{')"/>
    <xsl:next-match/>
    <xsl:value-of select="if(    $suppress-foreign-lang 
                             and not(xml2tex:lang-to-babel-lang(@xml:lang) = ('greek',
                                                                              'arabic', 
                                                                              'hebrew', 
                                                                              'japanese', 
                                                                              'chinese', 
                                                                              'syriac', 
                                                                              'armenian'))) 
                          then ()
                          else '}'"/>
  </template>
  
  <template context="*[local-name() = $text-style-elements]
                      [@css:text-transform eq 'uppercase'
                       or exists(key('style', @role)[@css:text-transform eq 'uppercase'])]">
    <xsl:text>\uppercase{</xsl:text>
    <xsl:next-match/>
    <xsl:text>}</xsl:text>
  </template>
  
  <template context="dbk:para[@xml:lang][not(@xml:lang = $langs[1])]">
    <xsl:param name="suppress-select-lang" as="xs:boolean" select="false()"/>
    <xsl:if test="not($suppress-select-lang)">
      <xsl:value-of select="concat('\selectlanguage{', xml2tex:lang-to-babel-lang(@xml:lang), '}%&#xa;')"/>
      <xsl:next-match/>
      <xsl:if test="not(parent::dbk:footnote and not(following-sibling::*))">
        <xsl:value-of select="concat('\selectlanguage{', xml2tex:lang-to-babel-lang($langs[1]), '}')"/>
      </xsl:if>
    </xsl:if>
  </template>
  
  <!-- bibliographies -->
  
  <template context="dbk:bibliography">
    <rule name="thebibliography" type="env" break-after="2" break-before="1">
      <param>0</param>
      <text/>
    </rule>
  </template>
  
  <template context="dbk:bibliodiv">
    <rule name="bibsect" type="env">
      <param select="dbk:title"/>
      <text select="node() except dbk:title"/>
    </rule>
  </template>
  
  <template context="dbk:bibliomixed">
    <rule name="bibitem" type="cmd" break-before="1">
      <option>aaa(000)</option>
      <param select="@xreflabel"/>
      <text/>
    </rule>
  </template>
  
  <template context="dbk:biblioref
                    |dbk:citation">
    <rule name="cite" type="cmd">
      <param select="string-join(tokenize((@linkends, @linkend)[1], '\s'), ',')"/>
    </rule>  
  </template>
  
  <template context="dbk:bibliography[@role = ('Citavi', 'CSL')]">
    <xsl:variable name="bibtex-path" select="concat($path, '/', $basename, '-bibtex.bib')" as="xs:string"/>
    <rule name="bibliography" type="cmd" break-after="2" break-before="2">
      <param select="concat($basename, '-bibtex')"/>
    </rule>
    <file href="{$bibtex-path}" encoding="utf-8"/>
  </template>
  
  <template context="dbk:bibliography/dbk:biblioentry">
    <xsl:variable name="main-set" as="element(dbk:biblioset)"
                  select="(dbk:biblioset[@relation eq 'article'], dbk:biblioset[@relation eq 'inproceedings'], dbk:biblioset)[1]"/>
    <xsl:value-of select="concat('@', 
                                 if(matches($main-set/@relation, 'thesis')) 
                                   then 'phdthesis'
                                 else if(matches($main-set/@relation, 'broadcast')) 
                                   then 'misc'
                                 else if($main-set/@relation) then $main-set/@relation
                                 else 'misc', 
                                 '{',
                                 @xml:id,
                                 ',&#xa;')"/>
    <xsl:apply-templates mode="#current"/>
    <xsl:text>}&#xa;</xsl:text>
  </template>
  
  <template context="dbk:biblioentry[dbk:biblioset[@relation eq 'article']]/dbk:biblioset[@relation = ('journal', 'incollection', 'inproceedings')]">
    <xsl:value-of select="concat('journal={', ' ', dbk:title, '},&#xa;')"/>
  </template>
  
  <template context="dbk:biblioset/*"/>
  
  <template context="dbk:authorgroup">
    <xsl:text>author={</xsl:text>
    <xsl:for-each select="dbk:author">
      <xsl:apply-templates mode="#current"/>
      <xsl:if test="position() ne last()">
        <xsl:text> and </xsl:text>
      </xsl:if>
    </xsl:for-each>
    <xsl:text>},&#xa;</xsl:text>
    <xsl:if test="dbk:editor">
      <xsl:text>editor={</xsl:text>
      <xsl:for-each select="dbk:editor">
        <xsl:apply-templates mode="#current"/>
        <xsl:if test="position() ne last()">
          <xsl:text> and </xsl:text>
        </xsl:if>
      </xsl:for-each>
      <xsl:text>},&#xa;</xsl:text>
    </xsl:if>
  </template>
  
  <template context="dbk:personname"><!-- for above bibtex generating template -->
    <xsl:value-of select="string-join((dbk:firstname, dbk:othername[starts-with(@role, 'middle')], dbk:surname), ' ')"/>
  </template>
  
  <template context="dbk:author|dbk:editor"><!-- probably for authors in the article header? -->
    <xsl:value-of select="concat(dbk:personname/dbk:firstname, ' ', dbk:personname/dbk:surname)"/>
  </template>
  
  <template context="dbk:pubdate">
    <xsl:value-of select="concat('date={', ., '},&#xa;')"/>
  </template>
  
  <template context="dbk:publisher">
    <xsl:value-of select="concat('publisher={', dbk:publishername[1], '},&#xa;')"/>
  </template>
  
  <template context="dbk:pagenums">
    <xsl:value-of select="concat('pages={', ., '},&#xa;')"/>
  </template>
  
  <template context="dbk:volumenum">
    <xsl:value-of select="concat('number={', ., '},&#xa;')"/>
  </template>
  
  <template context="dbk:biblioset[not(following-sibling::dbk:biblioset[@relation = 'inproceedings'])]/dbk:title">
    <xsl:value-of select="concat('title={', ., '},&#xa;')"/>
  </template>

  <template context="dbk:biblioset[following-sibling::dbk:biblioset[@relation = 'inproceedings']]/dbk:title">
    <xsl:value-of select="concat('booktitle={', ., '},&#xa;')"/>
  </template>

  <template context="dbk:biblioid">
    <xsl:value-of select="concat(@class, '={', ., '},&#xa;')"/>
  </template>
  
  <template context="dbk:orderedlist">
    <xsl:variable name="list-type" as="xs:string?"
                  select="tr:enumerate-list-type((@numeration, 'arabic')[1], *:listitem[1]/@override)"/>
    <!-- use 1st override or if empty 1st override of sublist -->
    <xsl:variable name="override" as="xs:string?"
                  select="(*:listitem[1], 
                           *:listitem[1]/*:orderedlist[1]/*:listitem[1])[string-length(@override) gt 0][1]/@override"/>
    <xsl:variable name="start" as="xs:integer" 
                  select="if(string-length($override) gt 0 and @numeration) 
                          then tr:list-number-to-integer($override, @numeration) - 1
                          else 0"/>
    <xsl:variable name="level" select="count(ancestor::*:orderedlist|ancestor::*:itemizedlist) + 1" as="xs:integer"/>
    <xsl:variable name="level-roman" as="xs:string">
      <xsl:number value="$level" format="i"/>
    </xsl:variable>
    <xsl:value-of select="concat('&#xa;\begin{enumerate}',
                                 $list-type[not(matches(., '^\[\{\d+\.\}\]$'))],
                                 concat('&#xa;\setcounter{enum', 
                                        $level-roman, 
                                        '}{', 
                                        $start, 
                                        '}')[$start gt 0]
                                 )"/>
    <xsl:apply-templates mode="#current"/>
    <xsl:value-of select="'&#xa;\end{enumerate}&#xa;'"/>
  </template>

  <xsl:function name="tr:enumerate-list-type" as="xs:string">
    <xsl:param name="numeration" as="xs:string"/>
    <xsl:param name="override" as="xs:string?"/>
    <xsl:variable name="indizes"    select="tokenize($override, '\p{P}')[. ne '']"   as="xs:string*"/>
    <xsl:variable name="separators" select="tokenize($override, '[\w\d]+')[. ne '']" as="xs:string*"/>
    <xsl:variable name="list-type" as="xs:string"
                  select="     if($numeration eq 'loweralpha') then 'a'
                          else if($numeration eq 'upperalpha') then 'A'
                          else if($numeration eq 'lowerroman') then 'i'
                          else if($numeration eq 'upperroman') then 'I'
                          else                                      '1'"/>
    <xsl:value-of select="string-join(('[{',
                                      for $i in (1 to max((count($indizes), count($separators))))
                                      return if(    count($separators) gt count($indizes))
                                             then ($separators[$i], $list-type[$indizes[$i]])
                                             else ($list-type, $separators[$i]),
                                      '}]'         
                                      ), '')"/>
  </xsl:function>
  
  <xsl:function name="tr:list-number-to-integer" as="xs:integer">
    <xsl:param name="override" as="xs:string"/>
    <xsl:param name="list-type" as="xs:string"/>
    <xsl:variable name="counter" as="xs:string"
                  select="replace($override, '.*?([A-Z0-9]+).*', '$1', 'i')"/>
    <xsl:choose>
      <xsl:when test="$list-type = ('upperroman', 'lowerroman') and matches($counter, '[ivxlcdm]', 'i')">
        <xsl:value-of select="tr:roman-to-int($counter)"/>
      </xsl:when>
      <xsl:when test="$list-type = 'loweralpha' or matches($counter, '[a-z]')">
        <xsl:value-of select="string-length(substring-before('abcdefghijklmnopqrstuvwxyz', $counter)) + 1"/>
      </xsl:when>
      <xsl:when test="$list-type = 'upperalpha' or matches($counter, '[A-Z]')">
        <xsl:value-of select="string-length(substring-before('ABCDEFGHIJKLMNOPQRSTUVWXYZ', $counter)) + 1"/>
      </xsl:when>
      <xsl:when test="not($counter)">
        <xsl:value-of select="1"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="xs:integer((normalize-space($counter)))"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

</set>
